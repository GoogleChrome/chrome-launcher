{
  "_from": "spawn-wrap@=1.3.8",
  "_id": "spawn-wrap@1.3.8",
  "_inBundle": false,
  "_integrity": "sha512-Yfkd7Yiwz4RcBPrDWzvhnTzQINBHNqOEhUzOdWZ67Y9b4wzs3Gz6ymuptQmRBpzlpOzroM7jwzmBdRec7JJ0UA==",
  "_location": "/nyc/spawn-wrap",
  "_phantomChildren": {},
  "_requested": {
    "type": "version",
    "registry": true,
    "raw": "spawn-wrap@=1.3.8",
    "name": "spawn-wrap",
    "escapedName": "spawn-wrap",
    "rawSpec": "=1.3.8",
    "saveSpec": null,
    "fetchSpec": "=1.3.8"
  },
  "_requiredBy": [
    "/nyc"
  ],
  "_resolved": "https://registry.npmjs.org/spawn-wrap/-/spawn-wrap-1.3.8.tgz",
  "_shasum": "fa2a79b990cbb0bb0018dca6748d88367b19ec31",
  "_shrinkwrap": null,
  "_spec": "spawn-wrap@=1.3.8",
  "_where": "/Users/benjamincoe/bcoe/nyc",
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "bugs": {
    "url": "https://github.com/isaacs/spawn-wrap/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "foreground-child": "^1.5.6",
    "mkdirp": "^0.5.0",
    "os-homedir": "^1.0.1",
    "rimraf": "^2.3.3",
    "signal-exit": "^3.0.2",
    "which": "^1.2.4"
  },
  "deprecated": false,
  "description": "Wrap all spawned Node.js child processes by adding environs and arguments ahead of the main JavaScript file argument.",
  "devDependencies": {
    "tap": "^10.1.0"
  },
  "files": [
    "index.js",
    "shim.js",
    "lib/is-windows.js"
  ],
  "homepage": "https://github.com/isaacs/spawn-wrap#readme",
  "license": "ISC",
  "main": "index.js",
  "name": "spawn-wrap",
  "optionalDependencies": {},
  "readme": "# spawn-wrap\n\nWrap all spawned Node.js child processes by adding environs and\narguments ahead of the main JavaScript file argument.\n\nAny child processes launched by that child process will also be\nwrapped in a similar fashion.\n\nThis is a bit of a brutal hack, designed primarily to support code\ncoverage reporting in cases where tests or the system under test are\nloaded via child processes rather than via `require()`.\n\nIt can also be handy if you want to run your own mock executable\ninstead of some other thing when child procs call into it.\n\n[![Build Status](https://travis-ci.org/tapjs/spawn-wrap.svg)](https://travis-ci.org/tapjs/spawn-wrap) [![Build status](https://ci.appveyor.com/api/projects/status/oea7gdvqa0qeijrm?svg=true)](https://ci.appveyor.com/project/isaacs/spawn-wrap)\n\n## USAGE\n\n```javascript\nvar wrap = require('spawn-wrap')\n\n// wrap(wrapperArgs, environs)\nvar unwrap = wrap(['/path/to/my/main.js', 'foo=bar'], { FOO: 1 })\n\n// later to undo the wrapping, you can call the returned function\nunwrap()\n```\n\nIn this example, the `/path/to/my/main.js` file will be used as the\n\"main\" module, whenever any Node or io.js child process is started,\nwhether via a call to `spawn` or `exec`, whether node is invoked\ndirectly as the command or as the result of a shebang `#!` lookup.\n\nIn `/path/to/my/main.js`, you can do whatever instrumentation or\nenvironment manipulation you like.  When you're done, and ready to run\nthe \"real\" main.js file (ie, the one that was spawned in the first\nplace), you can do this:\n\n```javascript\n// /path/to/my/main.js\n// process.argv[1] === 'foo=bar'\n// and process.env.FOO === '1'\n\n// my wrapping manipulations\nsetupInstrumentationOrCoverageOrWhatever()\nprocess.on('exit', function (code) {\n  storeCoverageInfoSynchronously()\n})\n\n// now run the instrumented and covered or whatever codes\nrequire('spawn-wrap').runMain()\n```\n\n## CONTRACTS and CAVEATS\n\nThe initial wrap call uses synchronous I/O.  Probably you should not\nbe using this script in any production environments anyway.\n\nAlso, this will slow down child process execution by a lot, since\nwe're adding a few layers of indirection.\n\nThe contract which this library aims to uphold is:\n\n* Wrapped processes behave identical to their unwrapped counterparts\n  for all intents and purposes.  That means that the wrapper script\n  propagates all signals and exit codes.\n* If you send a signal to the wrapper, the child gets the signal.\n* If the child exits with a numeric status code, then the wrapper\n  exits with that code.\n* If the child dies with a signal, then the wrapper dies with the\n  same signal.\n* If you execute any Node child process, in any of the various ways\n  that such a thing can be done, it will be wrapped.\n* Children of wrapped processes are also wrapped.\n\n(Much of this made possible by\n[foreground-child](http://npm.im/foreground-child).)\n\nThere are a few ways situations in which this contract cannot be\nadhered to, despite best efforts:\n\n1. In order to handle cases where `node` is invoked in a shell script,\n   the `PATH` environment variable is modified such that the the shim\n   will be run before the \"real\" node.  However, since Windows does\n   not allow executing shebang scripts like regular programs, a\n   `node.cmd` file is required.\n2. Signal propagation through `dash` doesn't always work.  So, if you\n   use `child_process.exec()` on systems where `/bin/sh` is actually\n   `dash`, then the process may exit with a status code > 128 rather\n   than indicating that it received a signal.\n3. `cmd.exe` is even stranger with how it propagates and interprets\n   unix signals.  If you want your programs to be portable, then\n   probably you wanna not rely on signals too much.\n4. It *is* possible to escape the wrapping, if you spawn a bash\n   script, and that script modifies the `PATH`, and then calls a\n   specific `node` binary explicitly.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/spawn-wrap.git"
  },
  "scripts": {
    "clean": "rm -rf ~/.node-spawn-wrap-*",
    "postpublish": "git push origin --all; git push origin --tags",
    "postversion": "npm publish",
    "preversion": "npm test",
    "test": "tap test/*.js"
  },
  "version": "1.3.8"
}
